
== Domains

ifeval::["{backend}" != "pdf"]

[inline-toc-header]#General#
[inline-toc]#<<Micronaut Data>>#
[inline-toc]#<<Domain Entities>>#
[inline-toc]#<<Reserved Domain Names>>#
[inline-toc]#<<Domain Requirements>>#
[inline-toc]#<<Duplicate Data (Sub-Classes)>>#

[inline-toc-header]#Fields#
[inline-toc]#<<Field Types>>#
[inline-toc]#<<Field Names>>#
[inline-toc]#<<Reserved Field Names>>#
[inline-toc]#<<Key Fields>>#
[inline-toc]#<<Unlimited Length String Fields>>#
[inline-toc]#<<Field Ordering>>#
[inline-toc]#<<Supported Annotations>>#

[inline-toc-header]#Persistence#
[inline-toc]#<<Repository Requirements>>#
[inline-toc]#<<Event Methods>>#
[inline-toc]#<<Transactions>>#
[inline-toc]#<<Initial Data Load>>#
[inline-toc]#<<Locking>>#


[inline-toc-header]#Relationships/Encoding#
[inline-toc]#<<Relationships>>#
[inline-toc]#<<Encoded Types>>#
[inline-toc]#<<Choice List>>#
[inline-toc]#<<Dates and Timezones>>#
[inline-toc]#<<Configurable Types>>#

[inline-toc-header]#Others#
[inline-toc]#<<Field Definitions>>#
[inline-toc]#<<toStringLocalized()>>#
[inline-toc]#<<Dynamic SQL - PreparedStatement>>#

endif::[]

// General
=== Domain Introduction

Your domain classes have a few requirements to be easily used by various pieces of the framework.
Your domain classes should be in proper packages, but that is not required.
See <<domain-testing>> for details on testing.


==== Micronaut Data

The https://micronaut-projects.github.io/micronaut-data/latest/guide/[Micronaut Data^]
icon:share-square-o[role="link-blue"]
persistence module is used by this framework to help you persist your data.
We use the https://micronaut-projects.github.io/micronaut-data/latest/guide/#jdbc[Micronaut Data JDBC^]
icon:share-square-o[role="link-blue"]
approach to avoid bringing in Hibernate or too many JPA modules.

Why Micronaut Data?  Simply, the GORM/Hibernate approach is very complex and brings in many
dependencies.  The most important problems include:

* *Sessions* - Hibernate sessions are needed to access the database.  Micronaut/Jackson tends to
             access the fields/proxies in other threads, outside of sessions.  This triggers the
             common 'no session for current thread' exceptions.  This problem forced us to add many
             work-arounds to add sessions to many locations.

* *Interceptor* Issues - GORM/Hibernate supports a save interceptor.  The problem is that it was
             not very reliable.

* *Session Cache* - The session cache is awesome and painful. Just search the web for
             "why I hate Hibernate".  We don't hate hibernate, but the session cache can easily
             get out of synch with reality.  That causes data corruption issues or bewildering
             exceptions. _NonUniqueObjectException_, _DuplicateKeyException_ and
             _HibernateSystemException_ are just a few of the hard-to-debug issues.

* *Unsaved Data* - Hibernate has a great feature that skips updates if no columns are changed.
             This causes problems when the changes are made that Hibernate is not aware of.
             This forced us to change fields, just to trigger the update and the event interceptor.

Because of these fragility issues, we decided to move closer to JDBC/SQL by using Micronaut Data.
This means we had to add some usability features (e.g. `save()` methods on _@DomainEntity_, etc).
But, the odd and bewildering exceptions for Hibernate are gone.

We found that very few of the Hibernate features were very important.  This includes:

* Lazy Loading or Proxying of Associations - Important, but we added work-arounds for
  the key cases (<<Simple Foreign Reference>> and <<parent-child-one-to-many>>.

* Optimistic <<Locking>> - We implemented a work-around for this too.


The features we did not really need include:

* Dirty Checking - Not important for most application scenarios.

* Persistence Contexts / Sessions - More of a problem than a feature.

* First Level Caching - Useful, but not as critical as originally thought.
  This lack makes the application code a little more complex to pass around the values.

* Second Level Caching - Only used in a few places, so we decided to implement in those places
  specifically (e.g. UserPreference).

The drawbacks for Hibernate out-weighed the benefits, so we migrated to a simpler solution.

==== Domain Entities

You define domain entities using annotations from <<Micronaut Data>> and this enterprise framework.
These annotations, along with repositories (see <<Repository Requirements>>), provide a simplified
API on the domain to process domain records.  It adds methods such as:

* save()
* delete()
* withTransaction()
* Lazy loaders for <<Simple Foreign Reference>> and <<parent-child-one-to-many>>
* Access to all repository interface methods (e.g. list(), findBy...()  and others))

A short example is shown below:

[source,groovy]
.Example - Simple Domain
----
@MappedEntity
@DomainEntity
class Order {
  String order
  Product product
  @Id @AutoPopulated UUID uuid  // <.>
}

interface OrderRepository extends BaseRepository, CrudRepository<Order, UUID> {
  Optional<Order> findByOrder(String order)  // <.>
  Optional<Order> findByUuid(UUID uuid)
  List<Order> list()
}

----
<.> Required for all domains.
<.> Exposed in the domain as `Order.findByOrder()`.


==== Reserved Domain Names

This framework has features that slightly restrict the name of the domain classes you can created.
This is mainly because of the way <<Markers and Models>> work.  A few names are used
to store elements in the marker model (a Map).  You should avoid the names
used by the <<StandardModelAndView>>.

==== Domain Requirements

There are a few requirements needed to implement domains in this framework:

* A UUID identifier with the name _'uuid'_.
* A version field (integer) for optimistic <<Locking>>.
* See <<Repository Requirements>> for more requirements on the domain's repository.

==== Duplicate Data (Sub-Classes)

Sometimes, you have common features that have the same fields in two or more related domains.
Normally, you could use inheritance to define a common base class with the common fields.
This would reduce the duplicate code to define the fields in multiple places.
The enterprise framework needs this with the common fields used by the
link:groovydoc/org/simplemes/eframe/custom/domain/FlexField.html[FlexField^] icon:share-square-o[role="link-blue"]
and
link:groovydoc/org/simplemes/eframe/custom/domain/FieldExtension.html[FieldExtension^] icon:share-square-o[role="link-blue"].

Micronaut-data currently does not really support use of sub-classes as domain classes.
This means you will have to duplicate the fields in both domains.

This duplication is not as bad as it seems.  Domains are usually simple data objects
with no real behavior.  Any common logic should be placed in a common service that can act
on the related domains.   You should use a normal interface to define the getters/setters for
the common fields. This will let the service work with all of the related domains.

This also has one other side-effect: the domains will be stored in separate tables.  This could be
avoided with some annotations, if needed.

// Fields
==== Field Names

Almost every piece of text displayed in a web-based GUI should be translatable to the user's language.
Since most of the fields in your domain classes will be displayed somewhere, the framework uses
some labelling conventions to reduce the boiler-plate code in your application.

Most of the GUI markers will determine the right label needed for a domain field based on the field's
name.  For example, if you want to display a list of orders, you would use the
<<reference.adoc#eflist,efList>> marker in your pages like this:

[source,html]
----
<@efList columns="order,product,status,qtyToBuild"/>
----

The _messages.properties_ file for you application would include these entries:

[source,groovy]
----
order.label=Order
orders.label=Orders
product.label=Product
status.label=Status
qtyToBuild.label=Quantity To Build
----

Note the use of the plural form of _"Order"_ that is used for fields that show multiples
(e.g. for the list's message _'1 to 8 of 200 Orders'_).  Most fields will not use a plural,
but they are used frequently for the top-level domain elements in GUI lists.

If you have not defined the entry in the _messages.properties_ file, then the framework will
show the key (_'order.label'_, etc).

==== Reserved Field Names

<<Micronaut Data>> and this framework use several domain field names for internal use and
your domains must have them:

[cols="1,4"]
|===
|Field Name|Description

|uuid|The internal database UUID field.
|version|The version of the record in the DB.  Used for optimistic locking.  Automatically maintained by the framework.
|===


==== Key Fields

All domain objects in most enterprise applications need some sort of key field definitions.
These are the specific key(s) needed to find and uniquely identify the object.  A common
example is an order object.  It will have a unique order name (ID) that
customers will reference when creating or working with the order.

A number of the framework features rely on this key field definition to make your application
coding simpler.  For example, the <<reference.adoc#eflist,efList>> marker relies on the key field
to implement the standard filter/search feature and
the hyper-links in lists.


===== Identifying Key Fields in Your Domain Classes

In all domains, you usually have one or more key fields.
This framework uses the <<Field Ordering>> mechanism and optional `keys` definitions to flag the right
key fields. For example, a work center domain might look like this:

.Example - Key Fields from fieldOrder
[source,groovy]
----
class WorkCenter {
  String workCenter
  String title

  static fieldOrder = ['workCenter', 'title']
}
----

In this case, the key field is assumed to be the `workCenter` field.

Sometimes, your `fieldOrder` list does not start with the key field, or you have two key fields.
This can be done with the `keys` static field:


.Example - Key Fields from keys static field
[source,groovy]
----
class Order {
  String order
  Customer customer
  BigDecimal qtyToBuild = 1.0

  static fieldOrder = ['customer', 'order', 'qtyToBuild', 'status']

  static keys = ['order']  // <.>
}
----
<.> The `keys` values are used to find the key field.

===== Primary Key Field

Many of this module's features require a single primary key field to reduce boiler-plate code.
For example, the <<json-by-key>> mechanism uses the primary key field to find other domain objects
when creating a foreign reference.  This is much simpler when you have a single key field.

To find this primary key field, the framework assumes the first key field is the primary
key field.

If you have domains with multiple key fields, then you should avoid using features like
<<json-by-key>>.  You will most likely get a domain record not found if you try to de-serialize
using <<json-by-key>> with multiple key fields.


==== Unlimited Length String Fields

Sometimes, you need an unlimited length text field in your domains.  To do this, you will need
to specify the column type for the DB:

[source,groovy]
.Example - Unlimited Length Field
----
  @Column(nullable = true)
  @MappedProperty(type = DataType.STRING, definition = 'TEXT')
  String preferencesText
----

==== Field Ordering

Frequently, the framework features will need to list or display your domain fields in a logical order.
Framework markers such as <<ef-show>> will show the fields in any order you like, but you would have to
update the `<@efShow/>` marker for every new field added to the domain class.
To simplify this maintenance task, the framework supports an optional
link:reference.html#field-order[fieldOrder^] icon:share-square-o[role="link-blue"]
static variable in domain classes.

WARNING: Philosophical Discussion Ahead!

Field ordering is not traditionally part of a domain class's definition.  Following the
'Don't Repeat Yourself' philosophy, a central place to store the field ordering
'hints' is needed.  We chose the domain class. This is optional. If you don't want to embed field
ordering in your domain classes, then you can specify the field ordering on the respective
<<reference.adoc#ef-show,efShow>> markers in your HTML files.  This means updating 3  files
whenever you add a new field to a domain class.  This is your choice.

See <<reference.adoc#field-order,fieldOrder >> for details.

==== Supported Annotations

There are many annotations that the enterprise framework has been tested with <<Micronaut Data>>.
This includes:

[cols="1,2,4",width=95%]
|===
|Annotation|Source | Description

| *@MappedEntity*|Micronaut| Defines a domain object.
| *@Transactional*|JPA/Jakarta| Specifies a method (or all methods) are transactional.
| *@Column*|JPA/Jakarta| Defines the column name, length and nullable flag (*nullable default*: true).
                         *Note:* If this is used with _@Nullable_, then the _@Column_ setting takes precedence.
| *@Nullable*|Java| Marks a field as nullable.  _@Column_ is a better choice.
| *@ManyToMany*|JPA/Jakarta| Defines a link between two domains in a many-to-many relationship.  Uses a join table.
| *@ManyToOne*|JPA/Jakarta| Defines the child side of a <<parent-child-one-to-many>>.
| *@OneToMany*|JPA/Jakarta| Defines the parent side of a <<parent-child-one-to-many>>.
| *@Join*|Micronaut| Defines the join logic for a query.  Suggested to only use on required foreign reference fields.
| *@ID*|Micronaut| Marks a field as the ID field.  Only UUID is supported.
| *@GeneratedValue*|Micronaut| Marks the field as auto-generated by the <<Micronaut Data>> layer.
| *@DateCreated*|Micronaut| Defines the date/time the record was created.
| *@DateUpdated*|Micronaut| Defines the date/time the record was last updated.
| *@MappedProperty*|Micronaut| Specifies the SQL type for the column.
|
|===


// Persistence
==== Repository Requirements

ifeval::["{backend}" != "pdf"]

[inline-toc]#<<Standard Repository Methods>>#
[inline-toc]#<<Support for H2 and Production Database>>#

endif::[]

A repository is a <<Micronaut Data>> mechanism to access your data.  These repositories follow a
number common patterns such as extending specific interfaces and implementing specific methods.
Most methods in the repository are automatically added to your domain class, so you rarely need
to use the repository directly.

Base interfaces include:

* BaseRepository
* CrudRepository<__Domain__, UUID>




===== Standard Repository Methods


<<Micronaut Data>> provides access to the database records using a number of naming patterns.
If your repository interface has a method that matches one of these patterns, then the SQL
will be generated automatically.

Some of the standard methods expected are:

[source,groovy]
.Example - Methods for most top-level domain repositories
----
interface OrderRepository extends BaseRepository, CrudRepository<Order, UUID> {
  Optional<Order> findByUuid(UUID uuid)  // <.>

  List<Order> list(Pageable pageable) // <.>
  long count() // <.>

  Optional<Order> findByOrder(String name) // <.>
  List<Order> list()  // <.>
}
----
<.> Reads a single record for the given ID. Used by many framework functions to find related records.
<.> Finds all records (with paging/sorting support).  Used by <<BaseCrudController>> to find records
    for the List <<Definition Pages>>.
<.> Counts all records.  Used by <<BaseCrudController>> to determine the paging limits
    for the List <<Definition Pages>>.
<.> Find by primary key.  Not used in framework, but useful for some application logic.
<.> Lists all records. Not used in framework, but useful for some application logic and debugging.

Most top-level domains that have List <<Definition Pages>> should provide the `list(Pageable)` and
`count()` methods.


===== Support for H2 and Production Database

Micronaut-Data requires that you define your database dialect in your repository (mostly).  The framework supports
using H2 (in memory) for testing and Postgres for production use.  To make this work you will need to define 3 separate
Micronaut-Data interfaces for access to these databases:

* __XYZ__Repository - Defines the methods common to all.
* __XYZ__RepositoryH2 - The test repository. Extends __XYZ__Repository.
* __XYZ__RepositoryPostgres - The production repository. Extends __XYZ__Repository.

The _XYZ_ domain will use the H2 repository for tests and the Postgres repository for production/dev.

Most of the method definitions will go in the base class.

[source,groovy]
.Example - Repositories
----
interface OrderRepository extends BaseRepository, CrudRepository<Order, UUID> {
  Optional<Order> findByOrder(String order)
  Optional<Order> findByUuid(UUID uuid)  <.>
  List<Order> list()  <.>
}

@JdbcRepository(dialect = Dialect.H2)
@Requires(env = [Environment.TEST]) // <.>
@Replaces(OrderRepository.class)    // <.>
interface OrderRepositoryH2 extends OrderRepository {
}

@JdbcRepository(dialect = Dialect.POSTGRES)
interface OrderRepositoryPostgres extends OrderRepository {  // <.>
}

----
<.> Required.
<.> Recommended for testing/diagnostics.  No row limits on results.
<.> Used only for Test environment.
<.> Replaces the Postgres version of the repository.
<.> Uses Postgres for all non-test environments.

NOTE: The H2 version of the repository is normally defined in the production src.  This allows
      other modules to use these repositories in their test scenarios.  This bloats the
      .jar files somewhat, but is unavoidable.

==== Event Methods

The object life-cycle events methods are called when certain events take place:

ifeval::["{backend}" != "pdf"]

[inline-toc]#<<validate Method>>#
[inline-toc]#<<beforeValidate Method>>#
[inline-toc]#<<beforeSave Method>>#
[inline-toc]#<<beforeDelete Method>>#

endif::[]




==== validate Method

You can add domain-specific validations to your domains with the `validate()` method:

[source,groovy]
.Example - validate Method
----
def validate() {
  if (fieldName && !NameUtils.isLegalIdentifier(fieldName)) {
    //error.201.message="{1}" is not a legal custom field name.  Must be a legal Java variable name.
    return new ValidationError(201, 'fieldName', fieldName)  // <.>
  }
  return null
}
----
<.> Validation failures can return a ValidationError or a List<ValidationError>.  Returning
    *null* means no errors were found.


==== beforeValidate Method

Sometimes you need to execute some logic in your domain class before `validate()` is called.
For example, you need to encrypt a password on save/validate.  If you define a `beforeValidate()`
method on your domain, then it will be executed by the helper's `validate()` method.  For example:

[source,groovy]
.Example - beforeValidate Method
----
def beforeValidate() {
  encryptPassword()
}
----

This will call the `encryptPassword()` before the validation is performed on the domain.

==== beforeSave Method

Sometimes you need to execute some logic in your domain class before every `save()`.  For example,
you need to encrypt a password on save.  If you define a `beforeSave()` method on your
domain, then it will be executed by the domain's `save()` method.

==== beforeDelete Method

Sometimes you need to execute some logic in your domain class before every `delete()`.
For example, you need to remove related records from other domains.

[source,groovy]
.Example - beforeDelete Method
----
def beforeDelete() {
  FieldGUIExtension.removeReferencesToField(domainClassName, fieldName)
}
----



==== Transactions

Database transactions are critical to enterprise applications.  The data must be saved in a
consistent state across several domains.  To support this, the framework uses <<Micronaut Data>>
for database access and forces transactions around all database updates/insert/deletes.

Most transactions are initiated at the <<Services>> layer, but also sometimes in the controllers.
You can use the _@Transactional_ annotation in beans or the `withTransaction()` method.

[source,groovy]
.Example withTransaction Usage
----
Order.withTransaction {  // <.>
  def order = Order.findByOrder('1234')
  ResolveWorkableRequest req = new ResolveWorkableRequest(lsn: order.lsns[0], order: order)
  def workable = resolveService.resolveWorkable(req)[0]
}
----
<.> Starts the transaction, if not already in a DB transaction.  This reads a domain that is passed
    to the service method.

NOTE: The framework checks for an active transaction on every insert/update/delete SQL statement.
      You will need to wrap those database method calls with _@Transactional, @Rollback_ or
      withTransaction.

The _@Transactional_ annotation only works in classes that are processed as beans in Micronaut.
This means you can't use this annotation in most test classes or in plain of groovy/java logic.

===== Transactions and Prepared Statements

Some internal logic in the framework needs to be executed in a transaction.  This is done
to avoid a DB connection leak that happens with PreparedStatements.  This means sometimes you
may need to wrap some logic with a transaction.  If you find an IllegalStateException
with the note: _'No active transaction for SQL statement'_, then you may need to wrap the logic
with a transaction.

The most common cases are automatically wrapped when needed in the framework.


==== Locking

Database locking is a tricky subject.  We take a very simplistic approach to locking:
Most updates take place using optimistic locking with a `version` field.
Pessimistic locking is possible with a specific query annotation.

Also, we enforce that all UPDATE/INSERT SQL requests must be in a database transaction.

===== Optimistic Locking

Optimistic locking is handled by altering the update queries to add _'and version = :version'_ and
to increment the version during the update.  This means an exception will be thrown if a
version field is not given or the record was updated by another user.

===== Pessimistic Locking

Pessimistic locking is handled by using an explicit SQL query in your repository.
You must handle this in your application code. For example:

[source,groovy]
.Example - Pessimistic Locking
----
interface LSNSequenceRepository extends BaseRepository, CrudRepository<LSNSequence, UUID> {
  @Query("select * from lsn_sequence o where o.uuid = :uuid for update ")  // <.>
  Optional<LSNSequence> findByUuidWithLock(UUID uuid)  // <.>
}
----
<.> Forces a lock on the record when read.
<.> We recommend that you add _'withLock'_ on the method name.

This will place the lock on the record when the query is executed.  It also means the lock
record values are returned with the `find()` method.  This prevents all other users from
changing this record until you commit/rollback the transaction.

// Relationships/Encoding
==== Relationships

ifeval::["{backend}" != "pdf"]

[inline-toc]#<<Simple Foreign Reference>>#
[inline-toc]#<<parent-child-one-to-many>>#
[inline-toc]#<<Many-to-Many Relationships>>#

endif::[]


Domain relationships are generally defined in the domain classes and handled with the
_@DomainEntity_ annotation.  This annotation adds the correct save(), delete and lazy loader
methods for some of the more common relationships.

==== Simple Foreign Reference

Simple foreign references are supported by the framework.  This means your domains can refer
to other domains and access the other domain's members as needed.  To do this, you have
to define your domain in a very specific way:

[source,groovy]
.Example - Simple Foreign Reference
----
@MappedEntity
@DomainEntity
class Order {
  @ManyToOne(targetEntity=Product)  // <.>
  Product product
}

class OrderService {
  void validate(Order order) {
    if (order.product.lotSize> 1.0) {  // <.>
      thrown new Exception(...)
    }
  }
}

----
<.> Defines the reference as a simple foreign reference.  The targetEntity is required  for simple
    foreign references.   This distinguishes it from a <<parent-child-one-to-many>>
    relationship.
<.> Reads the product record on first access.

This adds a lazy loader mechanism in the `getProduct()` method.  On first access, this will read
the Product (if not-null).

NOTE: This _targetEntity_ is used as a marker for a simple foreign reference.  Do not use
      the _targetEntity_ option for <<parent-child-one-to-many>> relationships.
      This is the mechanism for distinguishing between simple references and the
      parent side in parent/child relations.


===== Join and Nullable References

A simple foreign reference is handled by Micronaut-Data in different ways depending on whether
the reference is nullable.  Nullable references require the use of the SQL OUTER _@Join_ option,
which is not supported by H2 (in memory) database.  Non-nullable references can use the LEFT join
logic:

[source,groovy]
.Example - Non-nullable Foreign Reference
----
interface OrderRepository extends BaseRepository, CrudRepository<Order, UUID> {
  @Join(value = "product", type = Join.Type.LEFT)  <.>
  Optional<Order> findByUuid(UUID uuid)
}
----
<.> This will read the Product record using an SQL join.  It can be accessed with _order.product..._.

This works fine for non-nullable fields.  To make it work for nullable fields, we would need
to use the OUTER join mechanism.  Unfortunately, H2 does not support this.  To access
the Product record in that case, you would need to add `findByUuid()` calls in your code.

To avoid this extra code, the enterprise framework will add a simple lazy-loading
getter method to your domain class. This will load the foreign reference on its first access.

If you do use _@Join_ with your finders, then this lazy loading will avoid an extra DB read
as long as you have a `dateCreated` property in your domain class.

[[parent-child-one-to-many]]
==== Parent/Child Relationships (One-To-Many)

Parent/Child relationships are quite common in enterprise applications.  The children are
fully-owned by the parent.  Updates and deleting on the parent should update/delete the children.

The _@DomainEntity_ annotation will add a lazy loader method (e.g. `getChildren()` in the example
below).  This loader uses the `findAllByParent()` method in the repository.


[source,groovy]
.Example - Parent/Child Relationships (One-to-Many)
----
@MappedEntity
@DomainEntity
class Parent {
  @OneToMany(mappedBy="parent")
  List<Child> children  <.>
}

@MappedEntity
@DomainEntity
class Child {
  @ManyToOne
  Parent parent  <.>
}

interface ChildRepository extends BaseRepository, CrudRepository<Child, UUID> {
  List<Child> findAllByParent(Parent parent) <.>
  Optional<Child> findById(UUID uuid)
  List<Child> list()
}

----
<.> The child list must default to null, not an empty list. The lazy loader sets the field
    to an empty list when no records are found in the DB.
    This reference either needs a parameterized _List<>_ type or the _@OneToMany_ needs to
    specify a `targetEntity`.
<.> The reference to the parent record is one of the primary keys in the child record.
<.> The finder `findByXYZ()` must be defined to find the child records.  This is used by the lazy
    loader.

NOTE: On the @_ManyToOne_ annotation, do not use _targetEntity_.  It is used as a marker for a
      <<Simple Foreign Reference>>.

Also, if the child class implements the Java Comparable interface, then the list will be sorted
before it is saved and after it is loaded.  Do not implement this interface if the list is likely
to be huge (>1000 records).

==== Many-to-Many Relationships

Many-to-Many relationships are implemented using a join table that contains a reference
to the parent and to the related record. This is sometimes referred to as a list of foreign
references. You can implement them in two different ways:

. <<Many-to-Many - Join>> from a `find()` method.
. <<Many-to-Many - Lazy Loader>>.

You can use either approach or a combination of the two.  If you don't define a JOIN option
on the `find()` method, then you can still rely on the lazy loader to load the list on demand.
The _@DomainEntity_ annotation adds the `save()` and `delete()` logic to handle this join table.

Both approaches require a _@ManyToMany_ annotation.

==== Many-to-Many - Join

The Join approach requires the finders be defined with a _@Join_ annotation to join the values from
the DB.  This uses the _@ManyToMany_ annotation (from Jakarta) and a _@Join_ annotation to
the `findBy...()` method in your repository.

An example is shown below:

[source,groovy]
.Example - User Many-to-Many Relationship
----
class User {
  @ManyToMany(mappedBy = "userRole")
  List<Role> userRoles // <.>
}

interface UserRepository extends BaseRepository, CrudRepository<User, UUID> {
  @Join(value = "userRoles", type = Join.Type.LEFT_FETCH)
  Optional<User> findByUserName(String userName)
}
----
<.> A null list allows the lazy loader logic to be used too.

This will create a `user_role` table with a `user_id` and `role_id` field to link the two records.

==== Many-to-Many - Lazy Loader

The lazy loader approach is simpler.  It just requires the _@ManyToMany_ annotation (from Jakarta).
On first access, the list of references will be loaded and the foreign domain will be populated.

An example is shown below:

[source,groovy]
.Example - User Many-to-Many Relationship - No Join
----
class User {
  @ManyToMany(cascade = CascadeType.ALL, mappedBy = "userRole")
  List<Role> userRoles // <.>
}

interface UserRepository extends BaseRepository, CrudRepository<User, UUID> {
  Optional<User> findByUserName(String userName)
}
----
<.> A null list allows the lazy loader logic to be used too.

This will create a `users_role` table with a `user_id` and `role_id` field to link the two records.

==== Choice List

You will frequently need to present your user with a drop-down list of options to choose
from. This list can be fairly static, expandable or database-driven.

You can create these list in several ways:

* <<Enumerations>> (static list).
* <<Encoded Types>> - Expandable List - Code-Based (expandable in add-on modules).
* <<Database Values>>.

===== Enumerations

If you have a very static list of valid values, you can use an
enumeration.  Your enumeration should provide a `toStringLocalized()` method to help
generate the drop-down list.

The normal <<Definition Pages>> support this type of field.

A simple example is shown below:

[source,groovy]
.Example Enumeration - Enum Definition
----
enum ReportTimeIntervalEnum implements Comparable {
  TODAY( . . .),    // <.>
  YESTERDAY(. . .})
    . . .
  String toStringLocalized(Locale locale = null) {    // <.>
    return GlobalUtils.lookup("reportTimeInterval.${name()}.label", null, locale)
  }
}
----
<.> The list of valid values.  These are displayed in the order they are defined here.
<.> The method that will generate a human-readable form of the enumeration for the drop-down list.
    Typically based on a `lookup()` in the _messages.properties_ file.


[source,groovy]
.Example Enumeration - Domain Field
----
class Product {
  ReportTimeIntervalEnum reportTimeInterval // <.>
}
----
<.> This creates a single column (normally 255 chars wide) to hold the enumeration's `toString()` value.
    For example _'LAST_24_HOURS'_.


[source,groovy]
.Example Enumeration - _messages.properties_ File
----
reportTimeInterval.LAST_24_HOURS.label=Last 24 Hours
reportTimeInterval.LAST_7_DAYS.label=Last 7 Days
reportTimeInterval.LAST_30_DAYS.label=Last 30 Days
 . . .
----


===== Encoded Types


This is a list of values defined in your code, but it can be expanded by other modules.
This is commonly used for status codes that can be applied to a domain object.
Instead of using a separate domain class with a new database table, you define a class hierarchy
that defines all of the available status codes.

NOTE: Each module can define additional encoded types. See <<Encoded Types Provided By Additions>>.

For example, you might have a _BasicStatus_ that can be _EnabledStatus_ or _DisabledStatus_.
You want these to be stored in an _Order_ domain field like this:

[source,groovy]
.Example - BasicStatus Use
----
class Order {
  String key

  @Column(length = 12, nullable = true)
  @Nullable BasicStatus status = EnabledStatus.instance // <.>
  BasicStatus status = EnabledStatus.instance

}
----
<.> A simple reference to the BasicStatus, with a default value.
    The status database column will be a small length (12 chars in the example).
    If not specified, then the column will default to 255 characters.

The mapping of the BasicStatus to a database column is handled automatically by the
custom link:groovydoc/org/simplemes/eframe/data/EncodedType.html[EncodedType^]
icon:share-square-o[role="link-blue"].

If you create custom EncodedTypes, then you will need to register the base class
(like BasicStatus above) in an <<Addition>>


Then your code that checks the status can be simple and clear:

[source,groovy]
.Example - BasicStatus Use
----
def order = . . .
if (!order.status.enable) {
  throw new SomeException('Order is not enabled')
}
----

The GUI <<Definition Pages>> will show these two options in a drop-down list with localized text (e.g. 'Enabled'
and 'Disabled').  When saved, the selected status is stored in an encoded column in the database
automatically.


This all works by defining your types correctly.   See
link:groovydoc/org/simplemes/eframe/system/BasicStatus.html[BasicStatus^]
icon:share-square-o[role="link-blue"] for an example.

The parent class for the encoded/choice list provides the main contact point for most of the GUI
and database features.  The sub-classes provide the individual choices in the list.  The parent
class must provide a list of valid values for the sub-classes defined in the core code.

The basic class structure is shown below:


//workaround for https://github.com/asciidoctor/asciidoctor-pdf/issues/271
:imagesdir: {imagesdir-build}

[plantuml,"encodedTypeExample",align="center"]
.EncodedTypeList and EncodedType Classes
----
@startuml

interface EncodedTypeListInterface {
}


interface ChoiceListItemInterface {
  String toStringLocalized()
}

interface EncodedTypeInterface {
  String getId()
}

class BasicStatus {
  String getId()
  boolean isEnabled()
  List<Choice> getValues()
  String toStringLocalized()
}

class EnabledStatus {
  String id = 'ENABLED'
  boolean enabled = true
}

class DisabledStatus {
  String id = 'DISABLED'
  boolean enabled = false
}

ChoiceListItemInterface -- BasicStatus
EncodedTypeListInterface -- BasicStatus
EncodedTypeInterface -- BasicStatus
BasicStatus --|> EnabledStatus
BasicStatus --|> DisabledStatus


@enduml
----

//end workaround for https://github.com/asciidoctor/asciidoctor-pdf/issues/271
:imagesdir: {imagesdir-src}

This link:groovydoc/org/simplemes/eframe/system/BasicStatus.html[BasicStatus^]
icon:share-square-o[role="link-blue"] is used in the core framework and most
application modules.  These application modules define their own status codes (e.g.
_OrderStatus_) that are used throughout the application.  These include more states
such as `isDone()` and `isHold()`.   See the source code for details on
how to implement these types of statuses.

The link:groovydoc/org/simplemes/eframe/data/EncodedTypeListInterface.html[EncodedTypeListInterface^]
icon:share-square-o[role="link-blue"] and
link:groovydoc/org/simplemes/eframe/data/EncodedTypeInterface.html[EncodedTypeInterface^]
icon:share-square-o[role="link-blue"] are used to provide the valid choices and to store/retrieve
the value from the database.



===== Database Values

The most flexible approach to lists of valid values is to use a database reference.  This allows
your users to (normally) create new values of the records.  This is usually more work since
a new set of <<Definition Pages>> must be built and tested.

In the example below, we will reference a _Product_ from an _Order_ record.


[source,groovy]
.Example Database Values - Product Domain
----
class Product {
  String product
  String title
   . . .
}
----

[source,groovy]
.Example Database Values - Order Domain
----
class Order {
  String order
  BigDecimal qty
  Product product  // <.>
   . . .
}
----
<.> The order is defined to build a certain qty of a _Product_.  This is the reference to
    an existing domain object.

NOTE: This _Product_ is not a direct child of the _Order_.  The _Order_ can be deleted and
      the _Product_ will still be in the database.

This type of relationship will usually be displayed as a single-selection combobox in
the normal edit/create pages.


==== Dates and Timezones

Dates and timezones are a common problems with enterprise systems.  Most common SQL databases
don't support timezones for values stored in the original SQL date/time columns.  Also, the GUI
toolkit doesn't support timezones.  The toolkit doesn't need to know the timezone since
the GUI elements don't need it.

To keep the date/times consistent
in the database, we always force the time to be stored in the UTC timezone.  Then, when the date/time
is displayed to the user, a global UI timezone is used.
This global UI default timezone is set to eastern US timezone by default.

To make this work, the JVM's default timezone is set to UTC by the StartupHandler.
This means the JDBC drivers and
the data layer will store the time in UTC.  Then, when the value is retrieved from the database and
sent to a client using JSON, the ISO date is sent with the timezone offset.  Then on the client,
the Javascript time is created by discarding the timezone offset.  This means the time will be
displayed by the toolkit with no adjustments.


==== toStringLocalized()

A number of places in the framework rely on the `toStringLocalized()` in the
link:groovydoc/org/simplemes/eframe/i18n/GlobalUtils.html[GlobalUtils^]
icon:share-square-o[role="link-blue"] utility class.
This allows the framework to provide a human-readable representation of your domain record for display.
For example, this is used in the <<reference.adoc#eflist,efList>> marker to build the
hyper-link text for the links generated.  Also, drop-down lists and archiving use this short
string format.

Most domains will not need to implement this method.  You won't need to implement this methods
if your domain has a single key and it is the first field in the <<Field Ordering,fieldOrder>>
static value.


==== Dynamic SQL - PreparedStatement

Sometimes, you just have to use SQL directly in your application code.  This is needed when
the _where_ clause criteria is flexible and changes based on user input.  You will need to use
the SQL directly.  This framework provides some helper classes to make this easier.
It also tries to make sure you use safe and portable SQL capabilities.

If you need dynamic sorting, then we recommend you the _Pageable_ support on most `list()`
repository methods.  See <<Standard Repository Methods>> for an example.

The most common scenario is to use a dynamically-generated SQL statement to find domain records.
The framework provides a simplified way to handle the most common case:

[source,groovy]
.Example - PreparedStatement - Query with limits
----

String sql = "SELECT * FROM LSN where order=?" // <.>
def list = SQLUtils.instance.executeQuery(sql,                   // <.>
                                          LSN,                   // <.>
                                          Pageable.from(0, 20),  // <.>
                                          order.uuid.toString()) // <.>

----
<.> We want to find a list of LSN records for the given Order (using UUID).
    This SQL could be created based on dynamic needs.
    See <<SQL Injection>> below for restrictions on this SQL query.
<.> The `execute()` method will execute the SQL, and return a list objects from the result set.
<.> The Domain object return (in a list).
<.> The results are limited to the first 20 rows.  Default: Page 0, page size 100.
<.> The parameters used in the SQL.


This will return a list of objects that match the selection criteria.  You need to make sure
the SQL includes at least one replaceable parameter.

WARNING: To avoid SQL Inject attacks on your application, always use static SQL queries.
         Never build the SQL directly from user inputs.  This method will reject
         queries that look like they might be used for injection attacks.  See <<SQL Injection>>
         below for details.

NOTE: To avoid connection leaks, the SQL must be executed in a transaction.
      This is enforced by the framework.


As an alternative, you can process the result set yourself if the normal binding mechanism
doesn't handle the cases you need (complex joins, etc).

[source,groovy]
.Example - PreparedStatement - Use ResultSet Directly
----

def list = []
String sql = "SELECT * FROM LSN where order=?"  // <.>
PreparedStatement ps
ResultSet rs
try {
  ps = SQLUtils.instance.getPreparedStatement(sql)
  ps.setString(1, order.getUuid().toString())
  ps.execute()
  rs = ps.getResultSet()
  while (rs.next()) {  // <.>
    list << SQLUtils.instance.bindResultSet(rs, LSN)  // <.>
  }
} finally {  // <.>
  try {
    rs?.close()
  } catch (Exception ignored) {  // <.>
  }
  ps?.close()
}

----
<.> We want to find a list of LSN records for the given Order (using UUID).
<.> Loop on the result set to build the domain object(s) (without saving).
<.> Will bind the columns from the result set, where possible. Ignored columns will be
    logged as warning messages.
<.> Must always close the prepared statement and result set.
<.> Need to make sure the prepared statement is closed, even if the result set close fails.


===== SQL Injection

SQL Injection is a serious security threat to all web-applications that use SQL.
The simplest way to avoid this is to never use any sort of dynamic SQL.  Chances are,
your application will require some sort of dynamic capability.

The framework provides this SQL access with some limitations.  These limitations reduce
the chance that an SQL injection attack will work on the query.

The limitations include:

* All dynamic SQL features will use the JDBC PreparedStatement approach.  PreparedStatement
  prevents most forms of SQL injection attacks using the values.  It does not prevent
  attacks if you build the SQL in an unsafe manner.
* Quotes (single or double) not allowed. For example,  _WHERE column='READY'_ is not allowed.
  You will need to use a parameter for cases like this.

The execute methods will fail if your SQL violates these rules.

include::configurableTypes.adoc[]
