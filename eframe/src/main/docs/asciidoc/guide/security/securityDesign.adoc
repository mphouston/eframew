
=== Security Design

This enterprise framework needs to support a few key configurable scenarios:

. User browser session timeout of short duration (e.g 30 minutes or less).
. Longer user browser session timeout (14+ days).
. JWT support for security on the <<API>> calls.

To support all of these cases, we chose to use JWT (Json Web Tokens) via browser cookies.
This allows a short JWT lifetime, with a long (configurable) automatic refresh mechanism for
browser-based clients.

One other important point:  Most requests should be authenticated with a stateless
mechanism.  This means the JWT is used to authenticate most requests since 
it does not use the DB or a session state to authenticate the request.  Instead, it
simply checks for validity.

Once the JWT expires (e.g. after 15 minutes), the token refresh is triggered that
checks for a valid refresh token (in the DB) from the original login.  It also checks the
User record in the DB for the user's status.

==== Token Timeouts

With this approach, the timeouts for the JWT and JWT_REFRESH_TOKEN are important.
If the values are too small or too large, then performance may suffer or your exposure
to security lapses may be too large.


===== access-token-expiration (micronaut.security...)

Suggested value: 1800 (30 minutes).

This setting defines the number of seconds for the JWT token will live after it is
created.  This means that any request with this token during that lifetime will
be allowed.  There will be no check for the User's status or for any other validations.

Making this value larger than 30 minutes means your exposure to security lapses will
last 30+ minutes.  If someone compromises your network and gets the JWT token,
they can make requests on the system.  If your JWT tokens expire quickly, then
the exposure is short.

Making this value less than 5 minutes will force too many expensive refresh requests
that access the database.

NOTE: If your network or devices are badly compromised, then there is little that
      the framework can do to prevent issues.  We can detect certain issues such as
      two users using the same refresh token.

===== eframe.security.jwtRefreshMaxAge

Suggested value: 1-14 days.

This age defines how long a refresh token can be used.  This is similar to the
traditional session timeout used by older web applications.  This is the time
when the framework will force the user to login again.

Every time a JWT token expires, the refresh mechanism will usually be triggered.
This refresh checks the database for the token.  It must be enabled, un-expired
and never used before.
The User's setting in the database is also checked.

Setting this value too large means the refresh token can be used a long time.  If
the refresh token is leaked, then it can be used to provide access to the system for
longer period of time.

This is mitigated by the fact that the token can only be used once.  The second attempt
to use the refresh token will disable all tokens for the user.
This will force the user to re-authenticate by logging in again.
A message is logged indicating a re-use was attempted.

Setting this value too small means your users will have to login more frequently.
There is no real downside to this beyond user expectations.


==== Refresh Token Flow

NOTE: This section assumes the access token timeout is set to the default 15 minutes and
      the refresh token timeout is set to the default 24 hours.  These numbers will
      used below without noting that they are the configurable values.
      See <<Security Setup>> for example settings.

The basic refresh flow is:

* Successful login sends access token (_JWT_) and refresh token (_JWT_REFRESH_TOKEN_)
  cookies (15min and 24 hours).
* All requests are checked for expired JWT.  If the JWT is expired, then the
  auto refresh of the token is attempted. The response will include the new JWT.
* If any of these refreshes fail, then the user will be forced to login at the next
  user request to the sever (e.g. on the nest page load or save).


The browser client-side logic requires no changes.  The normal browser cookie
handling logic should cover mode cases.

Any non-browser clients can request a refresh using a process similar to
<<oauth-refresh>> mechanism.


==== Refresh Token Details

Internally, the logic is a little more complex.  There are two Micronaut beans involved
in this:

* _AutoRefreshAuthenticationFetcher_ - This detects the expired JWT and triggers
  an auto token refresh for the request.  This class stores the new cookies in
  a request attribute for use by the other object.

* _AutoRefreshTokenFilter_ - This gets the cookies from the request and puts them
  in the response.



[[oauth-refresh]]
==== OAuth /oauth/access_token Endpoint Use

This endpoint is intentionally broken.  The replacement _/login/access_token_
provides a single-use replacement refresh token cookie when used.  The
_RefreshTokenService.getUserDetails()_ RefreshTokenPersistence implementation
intentionally prevents use of the tokens via the OAuth _/oauth/access_token_ endpoint.


