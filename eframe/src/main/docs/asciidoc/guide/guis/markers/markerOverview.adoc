
These are the Freemarker markers (template directive models) provided by the framework.  They
make building GUI simpler and provide the basic building blocks for most GUIs.

Most markers require the framework Javascript and CSS files. See the common
_views/includes/header.ftl_ for an example.


[[markers-common-features]]
==== Common Features

ifeval::["{backend}" != "pdf"]

[inline-toc]#<<Markers and Models>>#
[inline-toc]#<<Markers and Options,Markers and Options (Field-Specific)>>#
[inline-toc]#<<Markers and Labels>>#
[inline-toc]#<<pagination-filtering-and-sorting>>#

endif::[]



* Many of the GUI markers in the framework use <<GUI Toolkit>> elements for display.
These are Javascript GUI elements that rely on third party GUI features.

* For security reasons, all HTML output of text from markers is HTML encoded.

* Most markers are assumed to be executed within the HTML portion of the page.  They are rarely
executed inside of `<script></script>` sections.

* Most markers generate the full HTML/Javascript needed to render their elements.  This usually
includes a `<div>` to hold the elements and some javascript to render them.

Some of the common options supported by many markers include:

.Parameters
[cols="1,6"]
|===
|Argument|Description

| *id*    |The HTML ID used by the marker.  In some cases, this is used as a base for
           other UI elements generated by the marker.  This is also used
           as the ID for the toolkit internal IDs in some cases (*Default*: An ID based on the
           the marker name).

|===




===== Markers and Models

GUI markers frequently use domain objects and other objects to display values in the GUI.
This means the objects must be in the data model used by the Freemarker markers.

Built-in classes such as the show method in <<BaseCrudController>> will automatically store the
domain object in the model.  In your other methods, you will need to do something to store
the values in the model (a Map) to make them available to the markers and view pages.

For example, you might want a simple status page to display the values from a `Status` POGO.
The controller for this would look like this:

[source,groovy]
.Status Display Controller
----
@Controller("/status")
class StatusController {

  @Get("/display")
  StandardModelAndView show(HttpRequest request,Principal principal) {    // <.>
    def modelAndView = new StandardModelAndView('status/show', principal, this) // <.>
    modelAndView['status'] = new Status(...)  // <.>
    return
  }

}
----
<.> The show method returns a StandardModelAndView, which Freemarker will use to render the page.
<.> This uses the logged in user (principal) for some display details (e.g. for the logout button).
<.> The current status value is stored in the model for the view.


The status page might look like this:

[source,html]
.Status 'display' Page - .ftl
----
<#assign title><@efTitle label='status.title'/></#assign>

<#include "../includes/header.ftl" />

Status: ${status.codeText}             // <.>
Request Count: ${status.requestCount}  // <.>

Arguments: ${params.input}             // <.>

<#include "../includes/footer.ftl" />

----
<.> The `codeText` from the status model is displayed.
<.> The `requestCount` from the status model is displayed.
<.> The StandardModelAndView adds the request parameters to the model for
    use in your _.ftl_ files.  Each parameter is an entry in the `params` model.


===== Markers and Options

Some markers such as <<efShow>> process a list of fields to produce complex <<definition-pages,GUIs>>.
The markers allow you to provide options for the underlying widget.
This gives you more control over the fields generated.
The option names are of the format: _'field:option="value"'_.

For example, you can override the default label for a field:

[source,html]
.Override Default Field Label
----
<@efShow controller="User" user@label="customTitle.label"/> // <.>

----
<.> The title field has a custom title that is different from the default ('user.label').

Most of the simple options defined by the underlying widget (e.g.
link:groovydoc/org/simplemes/eframe/web/ui/webix/widget/TextFieldWidget.html[TextFieldWidget^]
icon:share-square-o[role="link-blue"])
are supported as arguments to the the `efShow` marker.

The markers that support this sub-field processing include:

* <<efShow>>
* <<efCreate>>
* <<efEdit>>


===== Adding to the HTML Head

Sometimes, you may need to add elements to the HTML _<head>_ section for custom stylesheets or
javascript.  To do this easily, the _header.ftl_ supports a block `head`.  It can be used like this:

[source,html]
.Example Custom Style Sheet for index.ftl
----
<#assign title><@efTitle label='logging.title'/></#assign>
<#assign head>
  <link rel="stylesheet" href="<@efAsset uri="/assets/logging.css"/>" type="text/css"> //<.>
</#assign>

<#include "../includes/header.ftl" />

 . . .


<#include "../includes/footer.ftl" />


----
<.> The style sheet _logging.css_ is included in the _<head>_ section.

===== Markers and Labels

Many markers support labels and tooltips.  We have some general rules for defining labels.
In places where labels are required (e.g. menus), then the marker determines the label
in precedence as follows:

. _label="value"_ - Uses the label value.  If it ends in .label, then it is looked up in the
 _messages.properties_ file and an optional tooltip is looked up by adding _".tooltip"_ instead
 of _".label"_.
. Uses some internal value (e.g. ID or key) to create the label by adding _".label"_ to the end.

Many markers that generate label elements support the _label_ and _tooltip_ options.


[[pagination-filtering-and-sorting]]
===== Pagination, Filtering and Sorting

Micronaut Data provides a good basis for the pagination, filtering and sorting mechanism for
most domain objects. The toolkit library generally uses the same type of pagination,
filtering and sorting as Micronaut Data, but the specific parameter names are different.
The parameters are shown below:

[cols="1,1,4"]
.Pagination, Filtering and Sorting
|===
| Micronaut Data | Toolkit | Description

| size | count | Number of rows per page (e.g. the number of rows retrieved).
| from | start | The page (or record number) to start the display at.  Note: on is a page (from) and
                 the other is a record number (start).
| sort|'sort[fieldName]=asc'|The sort column.  The toolkit combines this with the sort order.
| order|(see above)|The sort direction for the sort (asc or desc)
|===

If your application uses the `list()` method from the
link:groovydoc/org/simplemes/eframe/controller/BaseCrudController.html[BaseCrudController^]
icon:share-square-o[role="link-blue"] as described in <<Controller Base Classes>>,
then the conversion to the DB values is automatically done for you.

The link:groovydoc/org/simplemes/eframe/controller/ControllerUtils.html[ControllerUtils^]
icon:share-square-o[role="link-blue"] provides the methods
`calculateFromAndSizeForList()` and `calculateSortingForList()`
to provide the values needed for retrieval from the DB.

