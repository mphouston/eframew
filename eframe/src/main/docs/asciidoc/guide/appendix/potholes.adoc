
=== Potholes

Micronaut, GORM and the other tools are great, but they have some pot holes you need to avoid.
These pot holes are not terribly bad problems, but we have lost some time discovering them and
working around them.  This section is meant to help you avoid some of those pot holes.

==== groovy.lang.Singleton Used

Groovy provides the `groovy.lang.@Singleton` annotation without an explicit import.
This annotation is not compatible with the one needed by Micronaut (_javax.inject.Singleton_).
You must explicitly import the correct one:

  import javax.inject.Singleton

If you use the wrong annotation, then your bean will not be created.

NOTE: Intellij will not flag the wrong `@Singleton` annotation.  You will have to manually
      insert the above import statement.

// TODO: Find/document an automatic check for this.  On App startup?

==== Sessions Lost Randomly

If you experience logon sessions being lost randomly, then you may have a problem with
your cookie definition.  By default, then path defined for the security session cookie
is the path of the page being displayed.  This means you get a cookie for each page.

NOTE: This does not seem to be a problem for JWT Cookie security that is used by the framework.

When you logout and come back in or browse to other pages, you get multiple cookies.
This confuses the authentication logic and it thinks the page needs authentication
again.  This means you will get logon pages after you have logged on.

To avoid this, make sure your _application.yml_ sets the cookiePath:


[source,yml]
.application.yml - Avoid Session Loss.
----
micronaut:
  application:
    name: eframe
  session:
    http:
      cookiePath: /
----

==== HTTP Requests return Forbidden Status

With the Micronaut security, if a request's URI is not valid for any reason, then the server will
typically return the HTTP _Forbidden_ status.  This happens, even  if the user has permissions for the
URI.

If this happens in a unit test in your IDE, then try rebuilding the the project and re-running the test.

==== Traits and AST

Early attempts to use the really nice Groovy traits instead of base classes failed.   It seems
Groovy does not guarantee the Annotations such as _@Secured_ will work with traits.  This means
we had to place common CRUD/Rest methods in the controller base classes such as
<<BaseCrudController>>.

The symptoms of this problem was inconsistent evaluation of the @_Secured_ annotation in other modules
that resulted in the annoying FORBIDDEN HTTP response.  This seemed to be worse when used in modules that
depended on the framework (e.g. <<{mes-core-path}/guide.adoc#,MES-Core Module>>).
See
http://docs.groovy-lang.org/next/html/documentation/core-traits.html#_compatibility_with_ast_transformations[Groovy Documents]
for details.


==== Geb/Selenium/Webdriver and moveToElement Issues/Messages

Under Firefox (and maybe others), the `moveToElement()` method moves relative to the element's
center. This is noted in an INFO message logged to stdError, but we suppress this in
the default GebConfig.groovy file:

  Logger.getLogger("org.openqa.selenium").setLevel(Level.WARNING)

You can change the logging level as needed.

There may also be other info messages from Selenium/Geb world that are suppressed.

==== Beans not defined for GEB/Spock Tests

When running a GEB/GUI test, the test spec starts an embedded server.  Sometimes, the micronaut
run-time doesn't see the controllers and other beans in your application.  If this happens, make
sure your _build.gradle_ has this dependency:

   compileOnly "io.micronaut:micronaut-inject-groovy"

This is in addition to the standard testCompile entry.  You need both.

One other symptom is in GEB tests, the page is not found. 

==== Dates with Groovy MONTH Syntax

Groovy has a nice array-based syntax for dates such as:

[source,groovy]
.Groovy MONTH Syntax
----
d[YEAR] = 2010
d[MONTH] = NOVEMBER
d[DATE] = 14
----

This is simple and easy to use, but the month values is zero-based (January=0) and the dates are 1-based.  This
inconsistency causes problems.  There are also issues with round trip access to the values that causes troubles.
For example, the code below fails unpredictably:

[source,groovy]
.Groovy MONTH Syntax - Fails
----
import static java.util.Calendar.*

def d = new Date()
d[YEAR] = 2010
d[MONTH] = NOVEMBER
d[DATE] = 14
d[HOUR_OF_DAY] = 13
d[MINUTE] = 24
d[SECOND] = 56
d[MILLISECOND] = 987

assert d[MONTH] == NOVEMBER
----

The failure of this code is dependent on the date that the test is run.  For this reason, we have chosen to avoid this
convenient approach to dates.

==== Constructors with more than One Optional Argument

Groovy provide a nice way to define optional arguments.  This is great, but the automatic class reloading
does not seem to work properly when 2 or more arguments are optional on constructors.  Groovy fails to call the
constructor on class recompilation. Also, 2 optional arguments are a
little confusing, so we avoid that scenario.  Traditional Java method overloading is used in those cases.

[source,groovy]
.Multiple Optional Arguments
----
GridWidget(Class domainClass, Collection list, Map options=null, List<String> columns=null) {
----

To solve this, we moved the `columns` list to the `options` map to eliminate the `columns` argument.


==== GStringTemplateEngine is Slow

When you need to evaluate a Groovy String with specific parameters, the standard way is to use the GStringTemplateEngine.
This is needed when you build the Groovy String from other elements or the user can provide their own string format.

[source,groovy]
.Slow GString Use
----
def parameters = [day: 'Monday', object: ...]
def engine = new groovy.text.GStringTemplateEngine()
def value = engine.createTemplate('${day}').make(parameters).toString()
----

This works and handles almost all cases, but it can be quite slow.  20-30 milliseconds per execution.  Even caching the
`engine` above does not help much.

To solve this, the enterprise framework provides a convenience method (`evaluateGString`) in
link:groovydoc/org/simplemes/eframe/misc/TextUtils.html[TextUtils^] to speed up the execution when possible:

[source,groovy]
.Fast GString Use
----
def parameters = [day: 'Monday', object: ...]
def value = TextUtils.evaluateGString('${day}',parameters)
----

This supports the normal Groovy String syntax such as _"${day} $day ${object.method()}"_.  If the method call format is used,
then the `evaluateGString()` method will use the slower GStringTemplateEngine approach if needed.

NOTE: Use the simple format such as _"$day"_ for speed.


==== @Canonical and @TupleConstructor Issues

We try to avoid these two.  The tuple constructor will create a constructor that frequently overlays the default value
for fields.  For example:

[source,groovy]
.@Canonical Issue
----
@Canonical
class Preference {
  String element
  String name=''
  List details = []
}

def preference = new Preference('ABC')
----

This will create an instance that has _null_ as the name and details element. The framework will avoid this tuple
constructor in most cases.


==== Map.class vs. Map.getClass()

This is a well-known quirk of Groovy.  In general, Groovy allows you to use the shorter _variable.class_ to get the
Class of the variable.  This works for most types of variables, but not for Maps.

When you have a map variable, the map.class returns the entry 'class' from the map.  This means you need to use
 _variable.getClass()_ instead.


==== Stub Compiler issues with .java

*Symptom:*

C:\Users\mph\.IntelliJIdea2016.1\system\compile-server\eframe_3d005332\groovyStubs\eframe_main\java-production\org\simplemes\eframe\custom\SomeClass.java
Error:(10, 8) java: java.lang.Comparable cannot be inherited with different arguments: <> and
<org.simplemes.eframe.custom.SomeClass>

This happens when compiling the Java stubs.  It happens when a true Java class calls
some Groovy code.

*Solution*

Move the Java source files to the Groovy directory.  The groovy compiler can handle them correctly.

*Alternate Solution*

Don't call Groovy code from Java in application code.


==== Hibernate NonUniqueObjectException and DuplicateKeyException

These exceptions will happen when the hibernate sessions get out of synch.  This happens when you do unusual
things in GORM.  Most simple read, update cycles will not cause this problem.  This will happen when
you try to make database updates in a hibernate event (e.g. beforeInsert, beforeValidate, etc).
These event methods are called when hibernate is flushing the session.
Trying to change the database during these methods will cause the session to get out of synch and
cause unpredictable errors.

For example, doing database updates in the <<beforeValidate Method>> can cause these
exceptions.  Using _withNewSession_ can fix this in some cases.  Other cases might be fixable by
re-reading the value.  See <<Custom Child List - Integration/GUI Testing>> for an example in testing.

==== HibernateSystemException Proxy for Two Open Sessions when GUI Testing

  HibernateSystemException: illegally attempted to associate a proxy with two open Sessions

This is caused by attempting to delete a custom child record in the cleanup section of the GUI test.
The custom child cleanup logic that deletes records is triggered in a different session.  This causes the
error in the GUI/GEB testing.  This is not an issue in production since one session is in use for most deletes.

This is probably due to code like this in your GUI test:

  static dirtyDomains = [Parent, CustomChild]

To fix this, use this order:

  static dirtyDomains = [CustomChild, Parent]

This exception can also be caused by loading a list of objects in one session and attempting to delete them
in another session.  See notes in `FieldExtensionHelper.handlePostDeleteEvent()`.


==== rejected value null on hasHone relationship

In GORM, a new quirk appeared.  If you have a one-to-one relationship between two objects and
you use the `belongsTo` with the `hasOne` relationship, you will get an error on save like this:


[source]
----
Field error in object 'Product' on field 'productRouting.product': rejected value [null];
----

This means the unit test mocks are not setting both ends of the one-to-on relationship for you.
The fix is simple: convert the `belongsTo` notation to a simple reference:

[source,groovy]
----
Product product
----

This is the way GORM expects these relationships to work.

==== Hibernate Does Not Save Unchanged Records

Hibernate is generally great, but these is one pothole that we fall into frequently.  This causes a lot of trouble
in testing if your forget about this.  Sometimes, we have to force an update by changing a value.  One common
approach is to change the `lastUpdated` field:

[source,groovy]
----
 order.lastUpdated = new Date(System.currentTimeMillis()+1)  // <.>
----
<.> Use the current time

====  org.hibernate.NonUniqueObjectException

Sometimes, when doing integration testing, the tests will fail with a NonUniqueObjectException exception such as:

  Caused by: org.hibernate.NonUniqueObjectException: A different object with the same identifier value was already associated with the session : [org.simplemes.mes.demand.Order#1]

This can sometimes be fixed by `withNewSession` or by re-reading the object using `get()`.  See
<<Custom Child List - Integration/GUI Testing>> for an example.

==== StackOverflowException and _StackOverflowError_

*Symptom:*

A stack overflow exception is thrown in unit tests and production when validating a
top-level object with a _hasOne_ child.  You can also get a _StackOverflowError_ in a unit test
when toString() is used by debugging or other testing mechanisms (e.g. Spock or IDE-based testing).

This can happen under these conditions:

* Both child and parent have `hashCode()` methods.  This can be the _@EqualsAndHashCode_ annotation or a normal method.
* The child uses the parent reference as part of its hash code.
* The parent uses the child reference as part of its hash code.

This can happen if you use the simple _@EqualsAndHashCode_ or _@ToString_:

[source,groovy]
----

@EqualsAndHashCode
@ToString
class Parent {
  String code
  static hasOne = [child: Child]
  . . .
}


@EqualsAndHashCode
@ToString
class Child {
  Parent parent
  . . .
}

----

This triggers a stack overflow in creating the hash codes since one level references the other.
The default behavior of the _@EqualsAndHashCode_ is to include *all* fields in the hash code calculation.
This causes the recursion and the stack overflow.


The solution is to make sure the parent hash code does not depend on the child's hash code:

[source,groovy]
----

@EqualsAndHashCode(includes=['code'])
@ToString
class Parent {
  String code
  static hasOne = [child: Child]
  . . .
}

@EqualsAndHashCode(includes=['parent'])  // <1>
@ToString(excludes = ['parent'])
class Child {
  Parent parent
  . . .
}

. . .

----
<1> This needed to make sure no other fields get pulled into the hash code.

NOTE: This can also happen with _@ToString()_.  You may need to add the option _excludes = ['order']_
      to the _@ToString()_ annotation.

==== Updates on Domains not Happening in GORM

*Symptom:*

A domain has a simple update to a field.  It makes the update with a simple assignment in the domain class
itself.  The save() does not actually update the database.

This is caused by the new GORM approach to dirty record checking.  As a side-effect of this change, simple
assignments don't seem to trigger the dirty record flag correctly.  For example:


[source,groovy]
----

@EqualsAndHashCode(includes=['code'])
class Parent {
  String code
  BigDecimal qty = 0.0

  def doSomeUpdates() {
    qty = 1.0               // <1>
    save()
  }
  . . .
}

----
<1> The change to the record is done with a simple assignment, not with the `setQty()` method.

This will not trigger the SQL update since GORM does not think the record changed.  To avoid this, you will
need to use this approach:

[source,groovy]
----

@EqualsAndHashCode(includes=['code'])
class Parent {
  String code
  BigDecimal qty = 0.0

  def doSomeUpdates() {
    setQty(1.0)               // <1>
    save()
  }
  . . .
}

----
<1> This will trigger the dirty record logic and force an update.

==== org.hibernate.MappingException on EncodedType

When starting the server, it will register all <<Encoded Types>>
with Hibernate.  If your module has not registered the types, then you will get the error:

----
  Caused by: org.hibernate.MappingException: Could not determine type for: org.simplemes.mes.demand.OrderStatus, at table: ordr, for columns: [org.hibernate.mapping.Column(overall_status)]
----

You will need to define the encoded types as noted in <<Encoded Types>>

==== Cannot set property 'Q' of undefined

When this happens deep in the <<GUI Toolkit>> library, it usually means a syntax error in the Javascript object passed to the toolkit constructor.

[source,javascript]
.Example - Undefined message from Toolkit
----
_B.display = {
  view: 'form', type: 'clean', margin: 0,
  rows: [
    {height: 10},
    ,                   // <.>
    { margin: 8,
      cols: [
        {view: "label", id: "rmaLabel", label: "rma.label", width: tk.pw(ef.getPageOption('labelWidth','20%')) , align: "right"},
        {view: "text", id: "rma", name: "rma", value: "RMA1001"  ,inputWidth: tk.pw("22em"),attributes: {maxlength: 40} }
      ]
    }
  ]
};
----

<.> This extra comma causes problems with the parsing of the object and the toolkit attempts to use an undefined GUI element.
Remove this extra comma to solve the problem.


==== Some Container won't Expand to Full Size

The <<GUI Toolkit>> library has some comprehensive tools for layout, but it does have some layout
quirks.  One good example is that a container (e.g. dialog) might not expand to the
given size (width) specified in the container creation.  


[source,javascript]
.Example - Dialog Size not Honored
----
ef.displayDialog({
  title: "Title",
  bodyURL: '/extension/dialog?dialog=extension/addPanelDialog',  // <.>
  width: '85%',  // <.>
  buttons: ['yes','no','cancel'],
  yes: function (dialogID,button) {
   return true;
  }
});
----

<.> The dialog has one field ('panel') that is about 400 pixels wide.
<.> The user or developer has made the dialog 85% wide.

This should result in a dialog that is 85% of the display width.  In some cases, it won't.
Instead, the dialog is always displayed as about 400 pixels wide, which is the rough width
of the 'panel' input field.

To avoid this, we need to add a variable width element after the 'panel' input field.
The normal <<efField>> mark does this for standard text fields by adding a spacer ({})
after the field.  This spacer will expand as needed to make the window the desired width.


