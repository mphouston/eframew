
=== JSON


ifeval::["{backend}" != "pdf"]

[inline-toc]#<<Persistence Aware Module for Jackson>>#
[inline-toc]#<<UUID Support>>#
[inline-toc]#<<json-by-key,@JSONByKey>>#
[inline-toc]#<<json-by-id,@JSONByID>>#
[inline-toc]#<<typeablemapper, Mapping Generic Objects to JSON (TypeableMapper)>>#

endif::[]



The enterprise framework uses JSON for external API access over HTTP.  We use the
https://github.com/FasterXML/jackson-docs[Jackson^] library for creating and reading JSON data.

==== Persistence Aware Module for Jackson

The
link:groovydoc/org/simplemes/eframe/json/EFrameJacksonModule.html[EFrameJacksonModule^]
icon:share-square-o[role="link-blue"] provides a number of features that your application will
use automatically:

* Reduce chances of infinite recursion when serializing parent/child relationships.
* Reduce JSON size for foreign references.
* Support for <<Encoded Types>>
* <<UUID Support>>.

This means you will rarely need to add Jackson annotations to your code to handle JSON issues.
There are a special cases you may need to use below:

==== UUID Support

The primary ID for most domain entities is a UUID.  This is generated by the <<Micronaut Data>>
layer when a record is created.  The UUID is always stored in a field name `uuid`.
This allows special-case handling that reduces the application level code.

One key area is in the JSON <<Rest API>>.  The support classes will handle UUID in special cases
to avoid creation of duplicate UUID's.  In particular, the <<BaseCrudRestController>> will
ignore the `uuid` field when creating new records.  This will force the persistence layer
to generate new UUID's on creation.


[[json-by-key]]
==== @JSONByKey

In some cases, you may need to serialize/deserialize a POGO that contains domain objects.
To make this JSON smaller, we provide an annotation that will use a single key field for the
serialization/deserialization process.  This makes things like the dashboard <<Undo>> capability
more smaller/simpler for the client.
The Undo feature use a JSON serialized POGO to define what needs to be done to undo an action.

NOTE: The field name annotated by this _@JSONByKey_ must be named the same as the domain class,
      with the first letter lower-cased. See `order` and `workCenter` below.

NOTE: This feature currently only works with the first primary key that is a string value.

[source,groovy]
.Example - @JSONByKey
----
class StartRequest {
  String barcode

  @JSONByKey
  Order order  // <.>

  @JSONByKey
  WorkCenter workCenter

  BigDecimal qty

  Date dateTime
}
----
<.> Will serialize this as _"order": "ORDER_123"_.  Just the primary key field will be used
    to access the database record for the `Order`.


This produces JSON similar to this:

[source,json]
.Example - JSON for @JSONByKey
----
{
    "barcode": "M1001",
    "order": "ORDER_123",
    "workCenter": "ASSEMBLY007",
    "qty": 1.2
}
----

When deserialized (in a transaction), this will find the Order and WorkCenter object and populate
them in POGO.

Some notes on error conditions:

* If the record can't be found in the database, then an exception is thrown at run time (deserialize).
* If the annotation _@JSONByKey_ is used on a non-domain field (e.g. a String or other field),
  then an exception will be triggered at run-time (serialize and deserialize).
* If the annotation _@JSONByKey_ is used on a field with a name that can't be converted to
  a domain class, then an exception will be triggered at run time (deserialize).
  (e.g. an `Order` field with a name 'theOrder'),

These errors are not detected at compile time.


[[json-by-id]]
==== @JSONByID

In some rare cases, you may need to serialize/deserialize a POGO that contains domain objects.
This is similar to <<json-by-key,@JSONByKey>>, but you need to use a record UUID instead of the key
field. To make this JSON smaller, we provide an annotation that will use the UUID only for the
serialization/deserialization process.  This makes things like the JSON processing
for other systems simpler.

NOTE: The field name annotated by this _@JSONByID_ must be named the same as the domain class,
      with the first letter lower-cased. See `order` and `workCenter` below.

[source,groovy]
.Example - @JSONByID
----
class StartRequest {
  String barcode
  @JSONByID Order order  // <.>
  @JSONByID WorkCenter workCenter
  BigDecimal qty
  Date dateTime
}
----
<.> Will serialize this as _"order": "dbb0c868-3ae5-4fd1-a0a4-e0ddda375e2b"_.
    Just the database record UUID will be used from the domain `Order`.


This produces JSON similar to this:

[source,json]
.Example - JSON for @JSONByID
----
{
    "barcode": "M1001",
    "order": "dbb0c868-3ae5-4fd1-a0a4-e0ddda375e2b",
    "workCenter": 4567,
    "qty": 1.2,
    "dateTime": null
}
----

When deserialized (in a transaction), this will find the Order and WorkCenter object and populate
them in POGO.

Some notes on error conditions:

* If the record can't be found in the database, then an exception is thrown at run time (deserialize).
* If the annotation _@JSONByID_ is used on a non-domain field (e.g. a String or other field),
  then an exception will be triggered at run-time (serialize and deserialize).
* If the annotation _@JSONByID_ is used on a field with a name that can't be converted to
  a domain class, then an exception will be triggered at run time (deserialize).
  (e.g. an `Order` field with a name 'theOrder'),

These errors are not detected at compile time.


==== TypeableMapper

The Jackson JSON mapper is very flexible, when the Class of the object being
de-serialized is know ahead of time. It does not easily handle reading
generic object when the Class is not known by the caller.
To work around this, the framework provides a
link:groovydoc/org/simplemes/eframe/json/TypeableMapper.html[TypeableMapper^] icon:share-square-o[role="link-blue"]
that will handle these scenarios.

To avoid security issues, this mapper will only read objects that are:

 *   Domain Entities - Must have the @MappedEntity annotation.
 *   Implements link:groovydoc/org/simplemes/eframe/json/TypeableJSONInterface.html[TypeableJSONInterface^]
     icon:share-square-o[role="link-blue"] - Specific classes marked with this interface

These objects can be in a list or a map.  To handle these scenarios, the mapper
creates/reads a JSON array with pairs of elements that specify the class name
and the value.  Maps also use a third element for the map entry name.

For lists, the array looks something like this:

[source,json]
.Example - TypeableMapper JSON Format
----
[ "org.simplemes.mes.demand.Order",  // <.>
  {
    "order": "SC1",                  // <.>
    "dateCompleted": "2013-05-11T18:29:50.307Z",
    "lsnTrackingOption": "ORDER_ONLY"
  },
  "org.simplemes.mes.action.ActionLog",  // <.>
  {
    "action": "RELEASE"
  }
]
----
<.> The class name for the first element.
<.> The value for the first element.
<.> Other class/value pairs.


An example that writes and reads the objects from a JSON file is shown below.


[source,groocy]
.Example - Using TypeableMapper for Write
----
def writer = new File("out.json").newWriter()
TypeableMapper.instance.start(writer)
TypeableMapper.instance.writeOne(writer, object1, true) // <.>
TypeableMapper.instance.writeOne(writer, object2, false)
TypeableMapper.instance.finish(writer)
writer.close()
----
<.> First object is written.


[source,groocy]
.Example - Using TypeableMapper for Read
----
def reader = new File("in.json").newReader()
def list = TypeableMapper.instance.read(reader)  // <.>

----
<.> A list of the objects is de-serialized from the file.
